-- Discovery: V_P_ARE_BILLERROR column structure
-- Run these against the database, then share results so we can
-- update the data dictionary and fix Query 3 in billing_blocks.

----------------------------------------------------------------------
-- 1. Column listing for V_P_ARE_BILLERROR
----------------------------------------------------------------------
SELECT
  COLUMN_NAME,
  DATA_TYPE,
  DATA_LENGTH,
  DATA_PRECISION,
  DATA_SCALE,
  NULLABLE,
  COLUMN_ID
FROM ALL_TAB_COLUMNS
WHERE TABLE_NAME = 'V_P_ARE_BILLERROR'
ORDER BY COLUMN_ID;

----------------------------------------------------------------------
-- 2. Column comments (if any)
----------------------------------------------------------------------
SELECT
  COLUMN_NAME,
  COMMENTS
FROM ALL_COL_COMMENTS
WHERE TABLE_NAME = 'V_P_ARE_BILLERROR'
  AND COMMENTS IS NOT NULL
ORDER BY COLUMN_NAME;

----------------------------------------------------------------------
-- 3. Sample data (first 10 rows) to understand content
----------------------------------------------------------------------
SELECT *
FROM V_P_ARE_BILLERROR
WHERE ROWNUM <= 10;

----------------------------------------------------------------------
-- 4. Verify our assumed blocking flag semantics
--    Check distinct values for the item-level block columns
--    to confirm 0 = ok, non-zero = flagged
----------------------------------------------------------------------
SELECT 'ITFREQSTAT' AS COL, ITFREQSTAT AS VAL, COUNT(*) AS CNT
FROM V_P_ARE_ITEM
WHERE ITSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
GROUP BY ITFREQSTAT
ORDER BY CNT DESC;

SELECT 'ITMEDNECSTAT' AS COL, ITMEDNECSTAT AS VAL, COUNT(*) AS CNT
FROM V_P_ARE_ITEM
WHERE ITSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
GROUP BY ITMEDNECSTAT
ORDER BY CNT DESC;

SELECT 'ITABN' AS COL, ITABN AS VAL, COUNT(*) AS CNT
FROM V_P_ARE_ITEM
WHERE ITSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
GROUP BY ITABN
ORDER BY CNT DESC;

----------------------------------------------------------------------
-- 5. Verify visit-level flag semantics
----------------------------------------------------------------------
SELECT 'VTREADY' AS COL, VTREADY AS VAL, COUNT(*) AS CNT
FROM V_P_ARE_VISIT
WHERE VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
GROUP BY VTREADY
ORDER BY CNT DESC;

SELECT 'VTHOLDRES' AS COL, VTHOLDRES AS VAL, COUNT(*) AS CNT
FROM V_P_ARE_VISIT
WHERE VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
GROUP BY VTHOLDRES
ORDER BY CNT DESC;

----------------------------------------------------------------------
-- 6. BILLERROR join path — does BERVTINTN link to VISIT?
--    If CNT > 0 the FK is confirmed.
----------------------------------------------------------------------
SELECT COUNT(*) AS MATCHED
FROM V_P_ARE_BILLERROR be
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = be.BERVTINTN;

----------------------------------------------------------------------
-- 7. BILLERROR → VISIT → ITEM join path
--    Confirms we can reach items through the visit.
----------------------------------------------------------------------
SELECT COUNT(*) AS MATCHED
FROM V_P_ARE_BILLERROR be
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = be.BERVTINTN
  INNER JOIN V_P_ARE_ITEM it
    ON it.ITVTINTN = vt.VTINTN;

----------------------------------------------------------------------
-- 8. Does BEORDER match V_P_ARE_VISIT.VTORGORDNUM?
--    If so, BEORDER identifies the accession directly.
----------------------------------------------------------------------
SELECT COUNT(*) AS MATCHED
FROM V_P_ARE_BILLERROR be
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTORGORDNUM = be.BEORDER;

----------------------------------------------------------------------
-- 9. Sample BILLERROR joined to VISIT — eyeball the relationship
----------------------------------------------------------------------
SELECT
  be.BEINTN,
  be.BERVTINTN,
  be.BERCODE,
  be.BERDESC,
  be.BEORDER,
  be.BERDTM,
  vt.VTREFNO        AS INVOICE_NO,
  vt.VTORGORDNUM    AS ACCESSION_NO,
  vt.VTSRVDT        AS SERVICE_DT
FROM V_P_ARE_BILLERROR be
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = be.BERVTINTN
WHERE ROWNUM <= 20
ORDER BY be.BERDTM DESC;

----------------------------------------------------------------------
-- 10. VTREADY semantics — what does each value look like?
--     Pull a few visits with VTREADY=1 and check VTSTAT, VTCHARGE
--     to see if 1 means "not ready" (held from billing).
----------------------------------------------------------------------
SELECT
  vt.VTINTN,
  vt.VTREFNO,
  vt.VTREADY,
  vt.VTSTAT,
  vt.VTCHARGE,
  vt.VTHOLDTILL,
  vt.VTHOLDRES,
  vt.VTSRVDT
FROM V_P_ARE_VISIT vt
WHERE vt.VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
  AND vt.VTREADY = 1
  AND ROWNUM <= 10;

----------------------------------------------------------------------
-- 11. ITABN — any other values historically?
----------------------------------------------------------------------
SELECT ITABN AS VAL, COUNT(*) AS CNT
FROM V_P_ARE_ITEM
GROUP BY ITABN
ORDER BY CNT DESC;

----------------------------------------------------------------------
-- 12. ITABN=2 — which tests/CPTs are flagged and how often?
----------------------------------------------------------------------
SELECT
  it.ITTSTCODE    AS TEST_CODE,
  it.ITCPTCD      AS CPT_CODE,
  it.ITDESC       AS ITEM_DESC,
  COUNT(*)        AS CNT
FROM V_P_ARE_ITEM it
WHERE it.ITABN = 2
  AND it.ITSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
GROUP BY it.ITTSTCODE, it.ITCPTCD, it.ITDESC
ORDER BY CNT DESC;

----------------------------------------------------------------------
-- 13. VTSTAT distribution — what visit statuses exist?
----------------------------------------------------------------------
SELECT VTSTAT AS VAL, COUNT(*) AS CNT
FROM V_P_ARE_VISIT
WHERE VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
GROUP BY VTSTAT
ORDER BY CNT DESC;

----------------------------------------------------------------------
-- 13b. VTSTAT cross-referenced with invoice/billing indicators
--      Helps us decode what each VTSTAT value means
----------------------------------------------------------------------
SELECT
  VTSTAT,
  CASE WHEN VTINVDT IS NULL THEN 'NO_INV' ELSE 'INV' END AS INV_STATUS,
  CASE WHEN VTFBDT IS NULL THEN 'NO_BILL' ELSE 'BILLED' END AS BILL_STATUS,
  VTREADY,
  VTCHARGE,
  COUNT(*) AS CNT
FROM V_P_ARE_VISIT
WHERE VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
GROUP BY
  VTSTAT,
  CASE WHEN VTINVDT IS NULL THEN 'NO_INV' ELSE 'INV' END,
  CASE WHEN VTFBDT IS NULL THEN 'NO_BILL' ELSE 'BILLED' END,
  VTREADY,
  VTCHARGE
ORDER BY VTSTAT, CNT DESC;

----------------------------------------------------------------------
-- 14. Invoice date (VTINVDT) — NULL vs populated
--     NULL likely = never invoiced
----------------------------------------------------------------------
SELECT
  CASE WHEN VTINVDT IS NULL THEN 'NO_INVOICE' ELSE 'INVOICED' END AS STATUS,
  COUNT(*) AS CNT
FROM V_P_ARE_VISIT
WHERE VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
GROUP BY CASE WHEN VTINVDT IS NULL THEN 'NO_INVOICE' ELSE 'INVOICED' END;

----------------------------------------------------------------------
-- 15. First bill date (VTFBDT) — NULL vs populated
----------------------------------------------------------------------
SELECT
  CASE WHEN VTFBDT IS NULL THEN 'NEVER_BILLED' ELSE 'BILLED' END AS STATUS,
  COUNT(*) AS CNT
FROM V_P_ARE_VISIT
WHERE VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
GROUP BY CASE WHEN VTFBDT IS NULL THEN 'NEVER_BILLED' ELSE 'BILLED' END;

----------------------------------------------------------------------
-- 16. Cross-tab: VTINVDT vs VTFBDT vs VTREADY
--     See how these three indicators correlate
----------------------------------------------------------------------
SELECT
  CASE WHEN VTINVDT IS NULL THEN 'NO_INV' ELSE 'INV' END AS INV_STATUS,
  CASE WHEN VTFBDT IS NULL THEN 'NO_BILL' ELSE 'BILLED' END AS BILL_STATUS,
  VTREADY,
  COUNT(*) AS CNT
FROM V_P_ARE_VISIT
WHERE VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
GROUP BY
  CASE WHEN VTINVDT IS NULL THEN 'NO_INV' ELSE 'INV' END,
  CASE WHEN VTFBDT IS NULL THEN 'NO_BILL' ELSE 'BILLED' END,
  VTREADY
ORDER BY CNT DESC;

----------------------------------------------------------------------
-- 17. Visits with billing errors — are they uninvoiced?
--     Check VTINVDT and VTFBDT on error visits
----------------------------------------------------------------------
SELECT
  CASE WHEN vt.VTINVDT IS NULL THEN 'NO_INV' ELSE 'INV' END AS INV_STATUS,
  CASE WHEN vt.VTFBDT IS NULL THEN 'NO_BILL' ELSE 'BILLED' END AS BILL_STATUS,
  vt.VTREADY,
  COUNT(DISTINCT vt.VTINTN) AS VISIT_CNT
FROM V_P_ARE_BILLERROR be
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = be.BERVTINTN
WHERE vt.VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
GROUP BY
  CASE WHEN vt.VTINVDT IS NULL THEN 'NO_INV' ELSE 'INV' END,
  CASE WHEN vt.VTFBDT IS NULL THEN 'NO_BILL' ELSE 'BILLED' END,
  vt.VTREADY
ORDER BY VISIT_CNT DESC;

----------------------------------------------------------------------
-- 18. ITSTAT distribution — item-level status for uninvoiced visits
----------------------------------------------------------------------
SELECT it.ITSTAT, COUNT(*) AS CNT
FROM V_P_ARE_ITEM it
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = it.ITVTINTN
WHERE vt.VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
  AND vt.VTINVDT IS NULL
GROUP BY it.ITSTAT
ORDER BY CNT DESC;

----------------------------------------------------------------------
-- 19. Sample: uninvoiced visits with billing errors — eyeball
----------------------------------------------------------------------
SELECT
  vt.VTREFNO        AS INVOICE_NO,
  vt.VTORGORDNUM    AS ACCESSION_NO,
  vt.VTSRVDT        AS SERVICE_DT,
  vt.VTSTAT,
  vt.VTREADY,
  vt.VTCHARGE,
  vt.VTINVDT,
  vt.VTFBDT,
  be.BERDESC         AS ERROR_DESC,
  be.BERDTM          AS ERROR_DT
FROM V_P_ARE_BILLERROR be
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = be.BERVTINTN
WHERE vt.VTSRVDT >= TO_DATE('20260101', 'YYYYMMDD')
  AND vt.VTINVDT IS NULL
  AND ROWNUM <= 20;

----------------------------------------------------------------------
-- 20. Uninvoiced items — full detail with billing/charge info
--     Shows why items weren't charged: no CPT, no charge code,
--     no-charge reason, zero price, etc.
----------------------------------------------------------------------
SELECT
  vt.VTREFNO         AS INVOICE_NO,
  vt.VTORGORDNUM     AS ACCESSION_NO,
  vt.VTSRVDT         AS SERVICE_DT,
  vt.VTSTAT          AS VISIT_STATUS,
  vt.VTREADY         AS VISIT_READY,
  it.ITTSTCODE        AS TEST_CODE,
  it.ITCPTCD          AS CPT_CODE,
  it.ITCHARGECD       AS CHARGE_CODE,
  it.ITDESC           AS ITEM_DESC,
  it.ITPRICE          AS PRICE,
  it.ITUNITPRICE      AS UNIT_PRICE,
  it.ITGROSS          AS GROSS,
  it.ITBQNT           AS BILLED_QTY,
  it.ITNCREASON       AS NO_CHARGE_REASON,
  it.ITABN            AS ABN_FLAG,
  it.ITCCITINTN       AS CCI_FLAG,
  it.ITSTAT           AS ITEM_STATUS
FROM V_P_ARE_ITEM it
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = it.ITVTINTN
WHERE vt.VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
  AND vt.VTINVDT IS NULL
  AND ROWNUM <= 50
ORDER BY vt.VTSRVDT, vt.VTREFNO;

----------------------------------------------------------------------
-- 21. No-charge reason distribution on uninvoiced items
----------------------------------------------------------------------
SELECT it.ITNCREASON, COUNT(*) AS CNT
FROM V_P_ARE_ITEM it
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = it.ITVTINTN
WHERE vt.VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
  AND vt.VTINVDT IS NULL
GROUP BY it.ITNCREASON
ORDER BY CNT DESC;

----------------------------------------------------------------------
-- 22. Uninvoiced items — CPT and charge code presence
--     How many have a CPT? A charge code? Both? Neither?
----------------------------------------------------------------------
SELECT
  CASE WHEN it.ITCPTCD IS NOT NULL THEN 'HAS_CPT' ELSE 'NO_CPT' END AS CPT_STATUS,
  CASE WHEN it.ITCHARGECD IS NOT NULL THEN 'HAS_CDM' ELSE 'NO_CDM' END AS CDM_STATUS,
  CASE WHEN it.ITPRICE > 0 THEN 'HAS_PRICE' ELSE 'NO_PRICE' END AS PRICE_STATUS,
  vt.VTSTAT          AS VISIT_STATUS,
  COUNT(*)           AS CNT
FROM V_P_ARE_ITEM it
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = it.ITVTINTN
WHERE vt.VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
  AND vt.VTINVDT IS NULL
GROUP BY
  CASE WHEN it.ITCPTCD IS NOT NULL THEN 'HAS_CPT' ELSE 'NO_CPT' END,
  CASE WHEN it.ITCHARGECD IS NOT NULL THEN 'HAS_CDM' ELSE 'NO_CDM' END,
  CASE WHEN it.ITPRICE > 0 THEN 'HAS_PRICE' ELSE 'NO_PRICE' END,
  vt.VTSTAT
ORDER BY CNT DESC;

----------------------------------------------------------------------
-- 23. DIAGNOSTIC: Do uninvoiced visits have ANY items at all?
--     If this returns 0, the visits exist but never got items posted.
----------------------------------------------------------------------
SELECT COUNT(*) AS ITEM_COUNT
FROM V_P_ARE_ITEM it
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = it.ITVTINTN
WHERE vt.VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
  AND vt.VTINVDT IS NULL;

----------------------------------------------------------------------
-- 24. Uninvoiced visits — VTSTAT breakdown with item presence
--     LEFT JOIN so we can see visits with and without items.
----------------------------------------------------------------------
SELECT
  vt.VTSTAT,
  CASE WHEN it.ITINTN IS NOT NULL THEN 'HAS_ITEMS' ELSE 'NO_ITEMS' END AS ITEM_PRESENCE,
  COUNT(DISTINCT vt.VTINTN) AS VISIT_CNT
FROM V_P_ARE_VISIT vt
  LEFT JOIN V_P_ARE_ITEM it
    ON it.ITVTINTN = vt.VTINTN
WHERE vt.VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
  AND vt.VTINVDT IS NULL
GROUP BY
  vt.VTSTAT,
  CASE WHEN it.ITINTN IS NOT NULL THEN 'HAS_ITEMS' ELSE 'NO_ITEMS' END
ORDER BY VISIT_CNT DESC;

----------------------------------------------------------------------
-- 25. Uninvoiced visits with billing errors — do THOSE have items?
--     These are the ones we really care about.
----------------------------------------------------------------------
SELECT
  CASE WHEN it.ITINTN IS NOT NULL THEN 'HAS_ITEMS' ELSE 'NO_ITEMS' END AS ITEM_PRESENCE,
  vt.VTSTAT,
  COUNT(DISTINCT vt.VTINTN) AS VISIT_CNT
FROM V_P_ARE_BILLERROR be
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = be.BERVTINTN
  LEFT JOIN V_P_ARE_ITEM it
    ON it.ITVTINTN = vt.VTINTN
WHERE vt.VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
  AND vt.VTINVDT IS NULL
GROUP BY
  CASE WHEN it.ITINTN IS NOT NULL THEN 'HAS_ITEMS' ELSE 'NO_ITEMS' END,
  vt.VTSTAT
ORDER BY VISIT_CNT DESC;

----------------------------------------------------------------------
-- 26. Sample uninvoiced visits — what do they look like?
--     Pull visit-level detail without requiring items.
----------------------------------------------------------------------
SELECT
  vt.VTREFNO         AS INVOICE_NO,
  vt.VTORGORDNUM     AS ACCESSION_NO,
  vt.VTSRVDT         AS SERVICE_DT,
  vt.VTSTAT          AS VISIT_STATUS,
  vt.VTREADY         AS READY,
  vt.VTCHARGE        AS CHARGE_AMT,
  vt.VTPAID          AS PAID_AMT,
  vt.VTINVDT         AS INVOICE_DT,
  vt.VTFBDT          AS FIRST_BILL_DT,
  vt.VTCREATDTM      AS CREATED_DT,
  vt.VTTYPE          AS VISIT_TYPE,
  vt.VTFCLTY         AS FACILITY,
  vt.VTKIND          AS KIND
FROM V_P_ARE_VISIT vt
WHERE vt.VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
  AND vt.VTINVDT IS NULL
  AND ROWNUM <= 30
ORDER BY vt.VTSRVDT DESC;

----------------------------------------------------------------------
-- 27. What BILLERROR descriptions appear on uninvoiced visits?
--     This tells us what errors are actually blocking billing.
----------------------------------------------------------------------
SELECT
  be.BERDESC          AS ERROR_DESC,
  COUNT(DISTINCT vt.VTINTN)  AS VISIT_CNT,
  COUNT(*)            AS ERROR_CNT
FROM V_P_ARE_BILLERROR be
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = be.BERVTINTN
WHERE vt.VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
  AND vt.VTINVDT IS NULL
GROUP BY be.BERDESC
ORDER BY VISIT_CNT DESC;

----------------------------------------------------------------------
-- 28. ITSRVDT vs VTSRVDT — are items dated differently?
--     Maybe items exist but ITSRVDT is in a different range than VTSRVDT.
--     Check if any items exist for visits from 2025 regardless of ITSRVDT.
----------------------------------------------------------------------
SELECT
  CASE
    WHEN it.ITSRVDT >= TO_DATE('20250101','YYYYMMDD') THEN '2025+'
    WHEN it.ITSRVDT >= TO_DATE('20240101','YYYYMMDD') THEN '2024'
    WHEN it.ITSRVDT IS NULL THEN 'NULL'
    ELSE 'OLDER'
  END AS ITEM_SRV_YEAR,
  COUNT(*) AS CNT
FROM V_P_ARE_VISIT vt
  INNER JOIN V_P_ARE_ITEM it
    ON it.ITVTINTN = vt.VTINTN
WHERE vt.VTSRVDT >= TO_DATE('20250101', 'YYYYMMDD')
GROUP BY
  CASE
    WHEN it.ITSRVDT >= TO_DATE('20250101','YYYYMMDD') THEN '2025+'
    WHEN it.ITSRVDT >= TO_DATE('20240101','YYYYMMDD') THEN '2024'
    WHEN it.ITSRVDT IS NULL THEN 'NULL'
    ELSE 'OLDER'
  END
ORDER BY CNT DESC;
