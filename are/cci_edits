-- CCI (Correct Coding Initiative) Edits — Active Rules & Conflict Detection
-- Source views: V_S_ARE_CCI, V_S_ARE_CPTTABLE, V_S_ARE_MODIFIER, V_S_ARE_BILLRULES, V_P_ARE_ITEM
--
-- NOTE: ITCCITINTN is populated by the system at billing time, but CCI rules
-- in V_S_ARE_CCI get periodically refreshed (old CCINTN values replaced).
-- Query 2 shows system-flagged items via LEFT JOIN (tolerates orphaned keys).
-- Queries 3-4 use prospective self-join logic against current CCI rules.

----------------------------------------------------------------------
-- 1. Active CCI Edit Pairs
--    Shows all currently effective CCI rules with CPT descriptions.
----------------------------------------------------------------------
SELECT
  cci.CCINTN        AS CCI_ID,
  cci.CCPYOCODE     AS PAYOR_CODE,
  cci.CCCPT1        AS CPT_COLUMN1,
  cpt1.CPTDESC      AS CPT1_DESCRIPTION,
  CASE
    WHEN cpt1.CPTCODE IS NULL THEN 'NOT FOUND'
    WHEN cpt1.CPTSTAT <> 0 THEN 'INACTIVE'
    WHEN cpt1.CPTEXPDT IS NOT NULL AND cpt1.CPTEXPDT < SYSDATE THEN 'EXPIRED'
    ELSE 'ACTIVE'
  END               AS CPT1_STATUS,
  cci.CCCPT2        AS CPT_COLUMN2,
  cpt2.CPTDESC      AS CPT2_DESCRIPTION,
  CASE
    WHEN cpt2.CPTCODE IS NULL THEN 'NOT FOUND'
    WHEN cpt2.CPTSTAT <> 0 THEN 'INACTIVE'
    WHEN cpt2.CPTEXPDT IS NOT NULL AND cpt2.CPTEXPDT < SYSDATE THEN 'EXPIRED'
    ELSE 'ACTIVE'
  END               AS CPT2_STATUS,
  cci.CCERRCODE     AS ERROR_CODE,
  cci.CCFLAG        AS MODIFIER_INDICATOR,
  CASE cci.CCFLAG
    WHEN 0 THEN 'Not allowed'
    WHEN 1 THEN 'Allowed'
    WHEN 9 THEN 'N/A'
    ELSE 'Unknown (' || cci.CCFLAG || ')'
  END               AS MODIFIER_OVERRIDE,
  CASE cci.CCFLAG
    WHEN 1 THEN (
      SELECT LISTAGG(x.BRCCIMOD, ', ') WITHIN GROUP (ORDER BY x.BRCCIMOD)
      FROM (
        SELECT DISTINCT br.BRCCIMOD
        FROM V_S_ARE_BILLRULES br
        WHERE br.BRCPTCODE = cci.CCCPT2
          AND br.BRPYOCODE = cci.CCPYOCODE
          AND br.BRSTAT = 0
          AND br.BRCCIMOD IS NOT NULL
      ) x
    )
  END               AS CONFIGURED_CCI_MOD,
  cci.CCEFFDT       AS EFFECTIVE_DT,
  cci.CCEXPDT       AS EXPIRATION_DT
FROM V_S_ARE_CCI cci
  LEFT JOIN V_S_ARE_CPTTABLE cpt1
    ON cpt1.CPTCODE = cci.CCCPT1
  LEFT JOIN V_S_ARE_CPTTABLE cpt2
    ON cpt2.CPTCODE = cci.CCCPT2
WHERE cci.CCSTAT = 0
  AND cci.CCEFFDT <= SYSDATE
  AND (cci.CCEXPDT IS NULL OR cci.CCEXPDT >= SYSDATE)
ORDER BY cci.CCCPT1, cci.CCCPT2;

----------------------------------------------------------------------
-- 2. System-Flagged CCI Items
--    Items where SoftAR recorded a CCI hit at billing time (ITCCITINTN populated).
--    ITCCITINTN is a FK to the column-1 (grouped) item's ITINTN, not to
--    V_S_ARE_CCI.CCINTN.  We join back to V_P_ARE_ITEM to get the paired item,
--    then match against current CCI rules for the CPT pair.
--    Bind variables :start_date and :end_date (YYYYMMDD) for the service date range.
----------------------------------------------------------------------
SELECT
  vt.VTREFNO        AS INVOICE_NO,
  vt.VTORGORDNUM    AS ACCESSION_NO,
  -- Subordinate item (column 2 — the one flagged)
  it.ITINTN         AS ITEM_ID,
  it.ITVTINTN       AS VISIT_ID,
  it.ITSRVDT        AS SERVICE_DT,
  it.ITTSTCODE      AS TEST_CODE,
  it.ITDESC         AS ITEM_DESC,
  it.ITCPTCD        AS CPT_CODE,
  it.ITCPTMOD0      AS MODIFIER_0,
  mod0.MODDESC      AS MOD0_DESC,
  it.ITCPTMOD1      AS MODIFIER_1,
  it.ITCPTMOD2      AS MODIFIER_2,
  it.ITCPTMOD3      AS MODIFIER_3,
  it.ITMODFLAG      AS MOD_FLAG,
  DECODE(it.ITMODFLAG, 1, 'Allowed', 'Not Allowed') AS MOD_FLAG_DESC,
  -- Column 1 (grouped) item that this item conflicts with
  gr.ITINTN         AS COL1_ITEM_ID,
  gr.ITTSTCODE      AS COL1_TEST_CODE,
  gr.ITCPTCD        AS COL1_CPT_CODE,
  gr.ITDESC         AS COL1_ITEM_DESC,
  -- CCI rule detail (matched from current rules)
  cci.CCERRCODE     AS CCI_ERROR_CODE,
  cci.CCFLAG        AS CCI_MOD_INDICATOR,
  CASE cci.CCFLAG
    WHEN 0 THEN 'Not allowed'
    WHEN 1 THEN 'Allowed'
    WHEN 9 THEN 'N/A'
    ELSE 'Unknown (' || cci.CCFLAG || ')'
  END               AS CCI_MOD_OVERRIDE,
  cci.CCPYOCODE     AS CCI_PAYOR,
  CASE
    WHEN cci.CCINTN IS NULL THEN 'No current rule'
    ELSE 'Matched'
  END               AS CCI_RULE_STATUS,
  it.ITSTAT         AS ITEM_STATUS,
  it.ITFCLTY        AS FACILITY,
  (SELECT LISTAGG(x.BRCCIMOD, ', ') WITHIN GROUP (ORDER BY x.BRCCIMOD)
   FROM (
     SELECT DISTINCT br.BRCCIMOD
     FROM V_S_ARE_BILLRULES br
     WHERE br.BRTSTCODE = it.ITTSTCODE
       AND br.BRCPTCODE = it.ITCPTCD
       AND br.BRSTAT = 0
       AND br.BRCCIMOD IS NOT NULL
   ) x
  )                 AS CONFIGURED_CCI_MOD
FROM V_P_ARE_ITEM it
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = it.ITVTINTN
  INNER JOIN V_P_LAB_ORDER lo ON lo.ID = vt.VTORGORDNUM
  INNER JOIN V_P_LAB_STAY s ON s.AA_ID = lo.STAY_AA_ID
  INNER JOIN V_P_LAB_PATIENT p ON p.AA_ID = s.PATIENT_AA_ID
  -- Column-1 item: ITCCITINTN points to the grouped item's ITINTN
  INNER JOIN V_P_ARE_ITEM gr
    ON gr.ITINTN = it.ITCCITINTN
  -- Match against current CCI rules for this CPT pair
  LEFT JOIN V_S_ARE_CCI cci
    ON cci.CCCPT1 = gr.ITCPTCD
    AND cci.CCCPT2 = it.ITCPTCD
    AND cci.CCSTAT = 0
    AND cci.CCEFFDT <= it.ITSRVDT
    AND (cci.CCEXPDT IS NULL OR cci.CCEXPDT >= it.ITSRVDT)
  LEFT JOIN V_S_ARE_MODIFIER mod0
    ON mod0.MODCODE = it.ITCPTMOD0
WHERE REGEXP_LIKE(p.ID, '^E[0-9]+$')
  AND it.ITCCITINTN IS NOT NULL
  AND it.ITCCITINTN <> 0
  AND it.ITSRVDT >= TO_DATE(:start_date, 'YYYYMMDD')
  AND it.ITSRVDT <  TO_DATE(:end_date, 'YYYYMMDD') + 1
ORDER BY it.ITVTINTN, it.ITSRVDT, it.ITCPTCD;

----------------------------------------------------------------------
-- 3. Prospective CCI Conflict Detection (current rules)
--    Self-join billed items on the same visit + service date to find
--    CPT pairs that match active CCI edit rules.
--    Bind variables :start_date and :end_date (YYYYMMDD) for the service date range.
----------------------------------------------------------------------
SELECT
  vt.VTREFNO        AS INVOICE_NO,
  vt.VTORGORDNUM    AS ACCESSION_NO,
  it1.ITVTINTN      AS VISIT_ID,
  it1.ITSRVDT       AS SERVICE_DT,
  it1.ITINTN        AS ITEM1_ID,
  it1.ITTSTCODE     AS ITEM1_TEST,
  it1.ITCPTCD       AS ITEM1_CPT,
  it1.ITCPTMOD0     AS ITEM1_MOD,
  m1.MODDESC        AS ITEM1_MOD_DESC,
  it1.ITDESC        AS ITEM1_DESC,
  it2.ITINTN        AS ITEM2_ID,
  it2.ITTSTCODE     AS ITEM2_TEST,
  it2.ITCPTCD       AS ITEM2_CPT,
  it2.ITCPTMOD0     AS ITEM2_MOD,
  m2.MODDESC        AS ITEM2_MOD_DESC,
  it2.ITDESC        AS ITEM2_DESC,
  cci.CCERRCODE     AS CCI_ERROR_CODE,
  cci.CCFLAG        AS CCI_MOD_INDICATOR,
  CASE cci.CCFLAG
    WHEN 0 THEN 'Not allowed'
    WHEN 1 THEN 'Allowed'
    WHEN 9 THEN 'N/A'
    ELSE 'Unknown (' || cci.CCFLAG || ')'
  END               AS CCI_MOD_OVERRIDE,
  cci.CCPYOCODE     AS CCI_PAYOR,
  it1.ITFCLTY       AS FACILITY,
  (SELECT LISTAGG(x.BRCCIMOD, ', ') WITHIN GROUP (ORDER BY x.BRCCIMOD)
   FROM (
     SELECT DISTINCT br.BRCCIMOD
     FROM V_S_ARE_BILLRULES br
     WHERE br.BRTSTCODE = it2.ITTSTCODE
       AND br.BRCPTCODE = it2.ITCPTCD
       AND br.BRPYOCODE = cci.CCPYOCODE
       AND br.BRSTAT = 0
       AND br.BRCCIMOD IS NOT NULL
   ) x
  )                 AS CONFIGURED_CCI_MOD
FROM V_P_ARE_ITEM it1
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = it1.ITVTINTN
  INNER JOIN V_P_LAB_ORDER lo ON lo.ID = vt.VTORGORDNUM
  INNER JOIN V_P_LAB_STAY s ON s.AA_ID = lo.STAY_AA_ID
  INNER JOIN V_P_LAB_PATIENT p ON p.AA_ID = s.PATIENT_AA_ID
  INNER JOIN V_P_ARE_ITEM it2
    ON it2.ITVTINTN = it1.ITVTINTN
    AND TRUNC(it2.ITSRVDT) = TRUNC(it1.ITSRVDT)
    AND it2.ITINTN > it1.ITINTN
  INNER JOIN V_S_ARE_CCI cci
    ON cci.CCCPT1 = it1.ITCPTCD
    AND cci.CCCPT2 = it2.ITCPTCD
    AND cci.CCSTAT = 0
    AND cci.CCEFFDT <= it1.ITSRVDT
    AND (cci.CCEXPDT IS NULL OR cci.CCEXPDT >= it1.ITSRVDT)
  LEFT JOIN V_S_ARE_MODIFIER m1
    ON m1.MODCODE = it1.ITCPTMOD0
  LEFT JOIN V_S_ARE_MODIFIER m2
    ON m2.MODCODE = it2.ITCPTMOD0
WHERE REGEXP_LIKE(p.ID, '^E[0-9]+$')
  AND it1.ITSRVDT >= TO_DATE(:start_date, 'YYYYMMDD')
  AND it1.ITSRVDT <  TO_DATE(:end_date, 'YYYYMMDD') + 1
  AND it1.ITSTAT = 0
  AND it2.ITSTAT = 0
ORDER BY it1.ITVTINTN, it1.ITSRVDT, it1.ITCPTCD;

----------------------------------------------------------------------
-- 4. CCI Summary by CPT Pair
--    Aggregated count of CCI conflicts per CPT pair within the date range.
--    Useful for identifying the most frequent edit hits.
--    Bind variables :start_date and :end_date (YYYYMMDD) for the service date range.
----------------------------------------------------------------------
SELECT
  cci.CCCPT1        AS CPT_COLUMN1,
  cpt1.CPTDESC      AS CPT1_DESCRIPTION,
  cci.CCCPT2        AS CPT_COLUMN2,
  cpt2.CPTDESC      AS CPT2_DESCRIPTION,
  cci.CCERRCODE     AS ERROR_CODE,
  cci.CCPYOCODE     AS PAYOR_CODE,
  COUNT(*)          AS HIT_COUNT
FROM V_P_ARE_ITEM it1
  INNER JOIN V_P_ARE_VISIT vt
    ON vt.VTINTN = it1.ITVTINTN
  INNER JOIN V_P_LAB_ORDER lo ON lo.ID = vt.VTORGORDNUM
  INNER JOIN V_P_LAB_STAY s ON s.AA_ID = lo.STAY_AA_ID
  INNER JOIN V_P_LAB_PATIENT p ON p.AA_ID = s.PATIENT_AA_ID
  INNER JOIN V_P_ARE_ITEM it2
    ON it2.ITVTINTN = it1.ITVTINTN
    AND TRUNC(it2.ITSRVDT) = TRUNC(it1.ITSRVDT)
    AND it2.ITINTN > it1.ITINTN
  INNER JOIN V_S_ARE_CCI cci
    ON (   (cci.CCCPT1 = it1.ITCPTCD AND cci.CCCPT2 = it2.ITCPTCD)
        OR (cci.CCCPT1 = it2.ITCPTCD AND cci.CCCPT2 = it1.ITCPTCD))
    AND cci.CCSTAT = 0
    AND cci.CCEFFDT <= it1.ITSRVDT
    AND (cci.CCEXPDT IS NULL OR cci.CCEXPDT >= it1.ITSRVDT)
  LEFT JOIN V_S_ARE_CPTTABLE cpt1
    ON cpt1.CPTCODE = cci.CCCPT1
  LEFT JOIN V_S_ARE_CPTTABLE cpt2
    ON cpt2.CPTCODE = cci.CCCPT2
WHERE REGEXP_LIKE(p.ID, '^E[0-9]+$')
  AND it1.ITSRVDT >= TO_DATE(:start_date, 'YYYYMMDD')
  AND it1.ITSRVDT <  TO_DATE(:end_date, 'YYYYMMDD') + 1
  AND it1.ITSTAT = 0
  AND it2.ITSTAT = 0
GROUP BY
  cci.CCCPT1, cpt1.CPTDESC,
  cci.CCCPT2, cpt2.CPTDESC,
  cci.CCERRCODE, cci.CCPYOCODE
ORDER BY HIT_COUNT DESC;

