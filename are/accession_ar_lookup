-- Accession AR Lookup — All AR data for a single accession number
-- Source views: V_P_ARE_VISIT, V_P_ARE_ITEM, V_P_ARE_INVOICE,
--              V_S_ARE_TEST, V_S_ARE_CPTTABLE, V_S_ARE_PAYOR,
--              V_P_ARE_BILLERROR, V_S_ARE_ARERROR,
--              V_P_LAB_ORDERED_TEST, V_P_LAB_TEST_RESULT
-- Parameters:
--   :accession   accession/order number (e.g., '24-123456')

----------------------------------------------------------------------
-- Visit + Items + Invoice + Lab test state for one accession
----------------------------------------------------------------------
SELECT
  -- Visit
  vt.VTINTN                                  AS VISIT_INTN,
  vt.VTREFNO                                 AS INVOICE_NO,
  vt.VTORGORDNUM                             AS ACCESSION_NO,
  vt.VTSRVDT                                 AS SERVICE_DT,
  CASE vt.VTSTAT
    WHEN 0 THEN 'Pending'
    WHEN 1 THEN 'Active'
    WHEN 2 THEN 'Held'
    WHEN 3 THEN 'Cancelled'
    WHEN 4 THEN 'Other'
  END                                        AS VISIT_STATUS,
  CASE vt.VTREADY
    WHEN 0 THEN 'Ready'
    WHEN 1 THEN 'Not Ready'
  END                                        AS READY_STATUS,
  TO_CHAR(vt.VTINVDT, 'MM/DD/YYYY')         AS INVOICED_DT,
  TO_CHAR(vt.VTFBDT, 'MM/DD/YYYY')          AS FIRST_BILLED_DT,
  -- Item
  it.ITINTN                                  AS ITEM_INTN,
  it.ITTSTCODE                               AS TEST_CODE,
  tst.TSTDESC                                AS TEST_DESC,
  tst.TSTSYSCODE                             AS LAB_TEST_ID,
  it.ITCPTCD                                 AS CPT_CODE,
  cpt.CPTDESC                                AS CPT_DESC,
  it.ITCPTMOD0                               AS MOD0,
  it.ITCPTMOD1                               AS MOD1,
  it.ITCPTMOD2                               AS MOD2,
  it.ITCPTMOD3                               AS MOD3,
  it.ITPRICE / 100                           AS PRICE_DOLLARS,
  it.ITUNITS                                 AS UNITS,
  CASE it.ITSTAT
    WHEN 0 THEN 'Active'
    ELSE TO_CHAR(it.ITSTAT)
  END                                        AS ITEM_STATUS,
  -- Item flags
  CASE WHEN it.ITCCITINTN IS NOT NULL AND it.ITCCITINTN <> 0
       THEN 'Y' ELSE 'N' END                AS CCI_FLAGGED,
  it.ITCCITINTN                              AS CCI_LINK_ITINTN,
  DECODE(it.ITABN, 0,'N', 1,'Y', 2,'U', 3,'P', 4,'R', 5,'W', 6,'X', 7,'S') AS ABN_STATUS,
  CASE it.ITMODFLAG
    WHEN 0 THEN 'None'
    WHEN 1 THEN 'Payable w/ Modifier'
    ELSE 'Not Allowed'
  END                                        AS MOD_FLAG,
  -- Invoice
  inv.ININTN                                 AS INVOICE_INTN,
  inv.INEXT                                  AS INS_EXT,
  inv.INBILLTO                               AS BILL_TO_PAYOR,
  pyo.PYOCLASS                               AS PAYOR_CLASS,
  CASE pyo.PYOTYPE
    WHEN 0 THEN 'Insurance'
    WHEN 1 THEN 'Client'
    WHEN 2 THEN 'Self-Pay'
    WHEN 3 THEN 'Collection'
    WHEN 4 THEN 'Undetermined'
  END                                        AS PAYOR_TYPE,
  CASE inv.INSTAT
    WHEN 0 THEN 'Active'
    ELSE TO_CHAR(inv.INSTAT)
  END                                        AS INVOICE_STATUS,
  inv.INCHARGE / 100                         AS INVOICE_CHARGE,
  TO_CHAR(inv.INFBDT, 'MM/DD/YYYY')         AS INV_FIRST_BILLED,
  TO_CHAR(inv.INLBDT, 'MM/DD/YYYY')         AS INV_LAST_BILLED,
  -- Lab ordered test
  ot.WORKSTATION_ID                          AS LAB_WORKSTATION,
  ot.CANCELLED_FLAG                          AS LAB_CANCELLED,
  ot.ORDERING_DT                             AS LAB_ORDERED_DT,
  -- Lab result state (worst-case across components)
  tr_agg.RESULT_STATE                        AS LAB_RESULT_STATE,
  -- Context
  it.ITFCLTY                                 AS FACILITY,
  it.ITWARD                                  AS WARD
FROM V_P_ARE_VISIT vt
  LEFT JOIN V_P_ARE_ITEM it
    ON it.ITVTINTN = vt.VTINTN
  LEFT JOIN V_P_ARE_INVOICE inv
    ON inv.INVTINTN = vt.VTINTN
    AND inv.INEXT = it.ITINEXT
  LEFT JOIN V_S_ARE_PAYOR pyo
    ON pyo.PYOCODE = inv.INBILLTO
  LEFT JOIN V_S_ARE_TEST tst
    ON tst.TSTCODE = it.ITTSTCODE
  LEFT JOIN V_S_ARE_CPTTABLE cpt
    ON cpt.CPTCODE = it.ITCPTCD
  LEFT JOIN V_P_LAB_ORDER lo
    ON lo.ID = vt.VTORGORDNUM
  LEFT JOIN V_P_LAB_ORDERED_TEST ot
    ON ot.ORDER_AA_ID = lo.AA_ID
    AND ot.TEST_ID = tst.TSTSYSCODE
  LEFT JOIN (
    SELECT
      tr.ORDER_AA_ID,
      tr.GROUP_TEST_ID,
      tr.ORDERING_WORKSTATION_ID,
      MIN(tr.STATE)                          AS RESULT_STATE
    FROM V_P_LAB_TEST_RESULT tr
    WHERE tr.RESULT <> '.'
    GROUP BY tr.ORDER_AA_ID, tr.GROUP_TEST_ID, tr.ORDERING_WORKSTATION_ID
  ) tr_agg
    ON tr_agg.ORDER_AA_ID = ot.ORDER_AA_ID
    AND tr_agg.GROUP_TEST_ID = ot.TEST_ID
    AND tr_agg.ORDERING_WORKSTATION_ID = ot.WORKSTATION_ID
WHERE vt.VTORGORDNUM = :accession
ORDER BY it.ITCPTCD, it.ITINTN;

----------------------------------------------------------------------
-- Billing errors for the same accession (all, including warnings)
----------------------------------------------------------------------
SELECT
  vt.VTORGORDNUM                             AS ACCESSION_NO,
  be.BERDTM                                  AS ERROR_DT,
  NVL(be.BERCODE, 'IN75')                   AS ERROR_CODE,
  NVL(err.ERRDESC, be.BERDESC)              AS ERROR_DESC,
  CASE err.ERRACTION
    WHEN 0 THEN 'Abort'
    WHEN 1 THEN 'Skip'
    WHEN 2 THEN 'Warning'
    WHEN 3 THEN 'Ignore'
    WHEN 4 THEN 'Drop Item'
    WHEN 5 THEN 'Hold'
    WHEN 6 THEN 'Split'
    WHEN 7 THEN 'Split Warn'
    WHEN 8 THEN 'Hold & Bill Client'
  END                                        AS ERROR_ACTION,
  CASE err.ERRGRP
    WHEN 0 THEN 'Invoicing'
    WHEN 1 THEN 'Billing'
    WHEN 2 THEN 'Other'
    WHEN 3 THEN 'Posting'
    WHEN 4 THEN 'Remittance'
  END                                        AS ERROR_STAGE,
  be.BERDESC                                 AS RAW_DESC
FROM V_P_ARE_VISIT vt
  INNER JOIN V_P_ARE_BILLERROR be
    ON be.BERVTINTN = vt.VTINTN
  LEFT JOIN V_S_ARE_ARERROR err
    ON err.ERRCODE = NVL(be.BERCODE, 'IN75')
WHERE vt.VTORGORDNUM = :accession
ORDER BY be.BERDTM;

----------------------------------------------------------------------
-- 3. Lab order fallback — when queries 1 & 2 return nothing
--    Shows the SoftLab order + ordered tests so you can see why
--    the order may not have crossed into SoftAR.
----------------------------------------------------------------------
SELECT
  lo.ID                                      AS ORDER_NO,
  p.ID                                       AS MRN,
  p.LAST_NAME || ', ' || p.FIRST_NAME       AS PATIENT_NAME,
  lo.ORDERED_DT,
  lo.PRIORITY,
  lo.ORDERING_CLINIC_ID                      AS CLINIC,
  lo.REQUESTING_DOCTOR_ID                    AS DOCTOR,
  lo.NO_CHARGE,
  ot.TEST_ID,
  ot.WORKSTATION_ID,
  ot.CANCELLED_FLAG,
  ot.BILL_TYPE,
  tr_agg.RESULT_STATE
FROM V_P_LAB_ORDER lo
  INNER JOIN V_P_LAB_STAY s
    ON s.AA_ID = lo.STAY_AA_ID
  INNER JOIN V_P_LAB_PATIENT p
    ON p.AA_ID = s.PATIENT_AA_ID
  LEFT JOIN V_P_LAB_ORDERED_TEST ot
    ON ot.ORDER_AA_ID = lo.AA_ID
  LEFT JOIN (
    SELECT
      tr.ORDER_AA_ID,
      tr.GROUP_TEST_ID,
      tr.ORDERING_WORKSTATION_ID,
      MIN(tr.STATE)                          AS RESULT_STATE
    FROM V_P_LAB_TEST_RESULT tr
    WHERE tr.RESULT <> '.'
    GROUP BY tr.ORDER_AA_ID, tr.GROUP_TEST_ID, tr.ORDERING_WORKSTATION_ID
  ) tr_agg
    ON tr_agg.ORDER_AA_ID = ot.ORDER_AA_ID
    AND tr_agg.GROUP_TEST_ID = ot.TEST_ID
    AND tr_agg.ORDERING_WORKSTATION_ID = ot.WORKSTATION_ID
WHERE lo.ID = :accession
ORDER BY ot.TEST_ID;

----------------------------------------------------------------------
-- 4. Batch error lookup — paste multiple accessions
--    Replace the IN list with your accession numbers.
----------------------------------------------------------------------
SELECT
  vt.VTORGORDNUM                             AS ACCESSION_NO,
  vt.VTREFNO                                 AS INVOICE_NO,
  vt.VTSRVDT                                 AS SERVICE_DT,
  CASE WHEN vt.VTINVDT IS NULL THEN 'Uninvoiced'
       ELSE 'Invoiced' END                   AS INV_STATUS,
  TO_CHAR(vt.VTINVDT, 'MM/DD/YYYY')         AS INVOICED_DT,
  TO_CHAR(vt.VTFBDT, 'MM/DD/YYYY')          AS FIRST_BILLED_DT,
  NVL(be.BERCODE, 'IN75')                   AS ERROR_CODE,
  CASE err.ERRACTION
    WHEN 0 THEN 'Abort'   WHEN 1 THEN 'Skip'
    WHEN 2 THEN 'Warning' WHEN 3 THEN 'Ignore'
    WHEN 4 THEN 'Drop Item' WHEN 5 THEN 'Hold'
    WHEN 6 THEN 'Split'   WHEN 7 THEN 'Split Warn'
    WHEN 8 THEN 'Hold & Bill Client'
  END                                        AS ERROR_ACTION,
  CASE err.ERRGRP
    WHEN 0 THEN 'Invoicing' WHEN 1 THEN 'Billing'
    WHEN 2 THEN 'Other'    WHEN 3 THEN 'Posting'
    WHEN 4 THEN 'Remittance'
  END                                        AS ERROR_STAGE,
  be.BERDESC                                 AS RAW_DESC
FROM V_P_ARE_VISIT vt
  LEFT JOIN V_P_ARE_BILLERROR be
    ON be.BERVTINTN = vt.VTINTN
  LEFT JOIN V_S_ARE_ARERROR err
    ON err.ERRCODE = NVL(be.BERCODE, 'IN75')
WHERE vt.VTORGORDNUM IN (
    -- paste accession numbers here:
    'REPLACE_ME_1',
    'REPLACE_ME_2'
  )
ORDER BY vt.VTORGORDNUM, be.BERDTM;

----------------------------------------------------------------------
-- 5. Error distribution across ALL unbilled visits in date range
--    Shows which error codes are most common and at what stage.
--    Parameters: :start_date, :end_date (YYYYMMDD)
----------------------------------------------------------------------
SELECT
  NVL(be.BERCODE, 'IN75')                   AS ERROR_CODE,
  NVL(err.ERRDESC, '(no code match)')       AS ERROR_DESC,
  CASE err.ERRACTION
    WHEN 0 THEN 'Abort'   WHEN 1 THEN 'Skip'
    WHEN 2 THEN 'Warning' WHEN 3 THEN 'Ignore'
    WHEN 4 THEN 'Drop Item' WHEN 5 THEN 'Hold'
    WHEN 6 THEN 'Split'   WHEN 7 THEN 'Split Warn'
    WHEN 8 THEN 'Hold & Bill Client'
  END                                        AS ERROR_ACTION,
  CASE err.ERRGRP
    WHEN 0 THEN 'Invoicing' WHEN 1 THEN 'Billing'
    WHEN 2 THEN 'Other'    WHEN 3 THEN 'Posting'
    WHEN 4 THEN 'Remittance'
  END                                        AS ERROR_STAGE,
  COUNT(DISTINCT vt.VTINTN)                  AS VISIT_COUNT,
  COUNT(*)                                   AS ERROR_COUNT,
  MIN(vt.VTSRVDT)                            AS OLDEST_SERVICE_DT,
  MAX(vt.VTSRVDT)                            AS NEWEST_SERVICE_DT
FROM V_P_ARE_VISIT vt
  INNER JOIN V_P_LAB_ORDER lo
    ON lo.ID = vt.VTORGORDNUM
  INNER JOIN V_P_LAB_STAY s
    ON s.AA_ID = lo.STAY_AA_ID
  INNER JOIN V_P_LAB_PATIENT p
    ON p.AA_ID = s.PATIENT_AA_ID
  INNER JOIN V_P_ARE_BILLERROR be
    ON be.BERVTINTN = vt.VTINTN
  LEFT JOIN V_S_ARE_ARERROR err
    ON err.ERRCODE = NVL(be.BERCODE, 'IN75')
WHERE REGEXP_LIKE(p.ID, '^E[0-9]+$')
  AND vt.VTSRVDT >= TO_DATE(:start_date, 'YYYYMMDD')
  AND vt.VTSRVDT <  TO_DATE(:end_date, 'YYYYMMDD') + 1
  AND (vt.VTINVDT IS NULL OR vt.VTFBDT IS NULL)
GROUP BY
  NVL(be.BERCODE, 'IN75'),
  NVL(err.ERRDESC, '(no code match)'),
  CASE err.ERRACTION
    WHEN 0 THEN 'Abort'   WHEN 1 THEN 'Skip'
    WHEN 2 THEN 'Warning' WHEN 3 THEN 'Ignore'
    WHEN 4 THEN 'Drop Item' WHEN 5 THEN 'Hold'
    WHEN 6 THEN 'Split'   WHEN 7 THEN 'Split Warn'
    WHEN 8 THEN 'Hold & Bill Client'
  END,
  CASE err.ERRGRP
    WHEN 0 THEN 'Invoicing' WHEN 1 THEN 'Billing'
    WHEN 2 THEN 'Other'    WHEN 3 THEN 'Posting'
    WHEN 4 THEN 'Remittance'
  END
ORDER BY VISIT_COUNT DESC;
